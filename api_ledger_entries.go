/*
Core API

Marqeta's Core API endpoints, conveniently annotated to enable code generation (including SDKs), test cases, and documentation. Currently in beta.

API version: 3.0.19
Contact: support@marqeta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"github.com/shopspring/decimal"
)


// LedgerEntriesAPIService LedgerEntriesAPI service
type LedgerEntriesAPIService service

type LedgerEntriesAPIGetAccountLedgerEntryRequest struct {
	ctx context.Context
	ApiService *LedgerEntriesAPIService
	accountToken string
	ledgerEntryToken string
}

func (r LedgerEntriesAPIGetAccountLedgerEntryRequest) Execute() (*LedgerEntry, *http.Response, error) {
	return r.ApiService.GetAccountLedgerEntryExecute(r)
}

/*
GetAccountLedgerEntry Retrieve account ledger entry

Retrieve a ledger entry for a credit account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountToken Unique identifier of the credit account for which you want to retrieve ledger entries.  Send a `GET` request to `/credit/accounts` to retrieve existing credit account tokens.
 @param ledgerEntryToken Unique identifier of the ledger entry you want to retrieve.  Send a `GET` request to `/credit/accounts/{account_token}/ledgerentries` to retrieve existing ledger entry tokens.
 @return LedgerEntriesAPIGetAccountLedgerEntryRequest
*/
func (a *LedgerEntriesAPIService) GetAccountLedgerEntry(ctx context.Context, accountToken string, ledgerEntryToken string) LedgerEntriesAPIGetAccountLedgerEntryRequest {
	return LedgerEntriesAPIGetAccountLedgerEntryRequest{
		ApiService: a,
		ctx: ctx,
		accountToken: accountToken,
		ledgerEntryToken: ledgerEntryToken,
	}
}

// Execute executes the request
//  @return LedgerEntry
func (a *LedgerEntriesAPIService) GetAccountLedgerEntryExecute(r LedgerEntriesAPIGetAccountLedgerEntryRequest) (*LedgerEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LedgerEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LedgerEntriesAPIService.GetAccountLedgerEntry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{account_token}/ledgerentries/{ledger_entry_token}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_token"+"}", url.PathEscape(parameterValueToString(r.accountToken, "accountToken")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ledger_entry_token"+"}", url.PathEscape(parameterValueToString(r.ledgerEntryToken, "ledgerEntryToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LedgerEntriesAPIListAccountLedgerEntriesRequest struct {
	ctx context.Context
	ApiService *LedgerEntriesAPIService
	accountToken string
	count *int32
	startIndex *int32
	startDate *string
	endDate *string
	statuses *[]string
	description *string
	groups *[]string
	amount *decimal.Decimal
	expand *[]string
	sortBy *string
}

// Number of ledger entry resources to retrieve.
func (r LedgerEntriesAPIListAccountLedgerEntriesRequest) Count(count int32) LedgerEntriesAPIListAccountLedgerEntriesRequest {
	r.count = &count
	return r
}

// Sort order index of the first resource in the returned array.
func (r LedgerEntriesAPIListAccountLedgerEntriesRequest) StartIndex(startIndex int32) LedgerEntriesAPIListAccountLedgerEntriesRequest {
	r.startIndex = &startIndex
	return r
}

// Starting date of the date range from which to return ledger entries.
func (r LedgerEntriesAPIListAccountLedgerEntriesRequest) StartDate(startDate string) LedgerEntriesAPIListAccountLedgerEntriesRequest {
	r.startDate = &startDate
	return r
}

// Ending date of the date range from which to return ledger entries.
func (r LedgerEntriesAPIListAccountLedgerEntriesRequest) EndDate(endDate string) LedgerEntriesAPIListAccountLedgerEntriesRequest {
	r.endDate = &endDate
	return r
}

// Array of statuses by which to filter ledger entries.
func (r LedgerEntriesAPIListAccountLedgerEntriesRequest) Statuses(statuses []string) LedgerEntriesAPIListAccountLedgerEntriesRequest {
	r.statuses = &statuses
	return r
}

// Description of the ledger entries to return.
func (r LedgerEntriesAPIListAccountLedgerEntriesRequest) Description(description string) LedgerEntriesAPIListAccountLedgerEntriesRequest {
	r.description = &description
	return r
}

// Array of groups by which to filter ledger entries.  To return all ledger entry groups, do not include this query parameter.
func (r LedgerEntriesAPIListAccountLedgerEntriesRequest) Groups(groups []string) LedgerEntriesAPIListAccountLedgerEntriesRequest {
	r.groups = &groups
	return r
}

// Number of ledger entries to return.
func (r LedgerEntriesAPIListAccountLedgerEntriesRequest) Amount(amount decimal.Decimal) LedgerEntriesAPIListAccountLedgerEntriesRequest {
	r.amount = &amount
	return r
}

// Embeds the specified object into the response.
func (r LedgerEntriesAPIListAccountLedgerEntriesRequest) Expand(expand []string) LedgerEntriesAPIListAccountLedgerEntriesRequest {
	r.expand = &expand
	return r
}

// Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
func (r LedgerEntriesAPIListAccountLedgerEntriesRequest) SortBy(sortBy string) LedgerEntriesAPIListAccountLedgerEntriesRequest {
	r.sortBy = &sortBy
	return r
}

func (r LedgerEntriesAPIListAccountLedgerEntriesRequest) Execute() (*LedgerEntriesPage, *http.Response, error) {
	return r.ApiService.ListAccountLedgerEntriesExecute(r)
}

/*
ListAccountLedgerEntries List account ledger entries

Retrieve an array of ledger entries on a credit account.

This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>> and <</core-api/object-expansion, object expansion>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountToken Unique identifier of the credit account for which you want to retrieve ledger entries.  Send a `GET` request to `/credit/accounts` to retrieve existing credit account tokens.
 @return LedgerEntriesAPIListAccountLedgerEntriesRequest

Deprecated
*/
func (a *LedgerEntriesAPIService) ListAccountLedgerEntries(ctx context.Context, accountToken string) LedgerEntriesAPIListAccountLedgerEntriesRequest {
	return LedgerEntriesAPIListAccountLedgerEntriesRequest{
		ApiService: a,
		ctx: ctx,
		accountToken: accountToken,
	}
}

// Execute executes the request
//  @return LedgerEntriesPage
// Deprecated
func (a *LedgerEntriesAPIService) ListAccountLedgerEntriesExecute(r LedgerEntriesAPIListAccountLedgerEntriesRequest) (*LedgerEntriesPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LedgerEntriesPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LedgerEntriesAPIService.ListAccountLedgerEntries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{account_token}/ledgerentries"
	localVarPath = strings.Replace(localVarPath, "{"+"account_token"+"}", url.PathEscape(parameterValueToString(r.accountToken, "accountToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "")
	}
	if r.statuses != nil {
		t := *r.statuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", t, "multi")
		}
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.groups != nil {
		t := *r.groups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groups", t, "multi")
		}
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
	}
	if r.expand != nil {
		t := *r.expand
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "expand", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "expand", t, "multi")
		}
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-createdTime"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LedgerEntriesAPIResendWebhookEventRequest struct {
	ctx context.Context
	ApiService *LedgerEntriesAPIService
	eventType string
	resourceToken string
}

func (r LedgerEntriesAPIResendWebhookEventRequest) Execute() (*WebhookEventResendContainerResponse, *http.Response, error) {
	return r.ApiService.ResendWebhookEventExecute(r)
}

/*
ResendWebhookEvent Resend credit event notification

Resends a credit event notification to your webhook endpoint.

Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty.
The event notification is resent to your webhook endpoint and also returned in the response to this request.

For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>.
For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventType Specifies the type of event you want to resend.
 @param resourceToken Unique identifier of the resource for which you want to resend a notification.  Send a `GET` request to `/credit/accounts/{account_token}/journalentries` to retrieve existing journal entry tokens.  Send a `GET` request to `/credit/accounts/{account_token}/ledgerentries` to retrieve existing ledger entry tokens.  Send a `GET` request to `/accounts/{account_token}/accounttransitions` to retrieve existing account transition tokens.  Send a `GET` request to `/credit/accounts/{account_token}/payments/{payment_token}` to retrieve existing payment transition tokens.  Send a `GET` request to `/accounts/{account_token}/statements` to retrieve existing statement summary tokens.  Send a `GET` request to `/accounts/{account_token}/delinquencystate/transitions` to retrieve existing delinquency state transition tokens.  Send a `GET` request to `/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}` to retrieve existing payment reminder tokens.
 @return LedgerEntriesAPIResendWebhookEventRequest
*/
func (a *LedgerEntriesAPIService) ResendWebhookEvent(ctx context.Context, eventType string, resourceToken string) LedgerEntriesAPIResendWebhookEventRequest {
	return LedgerEntriesAPIResendWebhookEventRequest{
		ApiService: a,
		ctx: ctx,
		eventType: eventType,
		resourceToken: resourceToken,
	}
}

// Execute executes the request
//  @return WebhookEventResendContainerResponse
func (a *LedgerEntriesAPIService) ResendWebhookEventExecute(r LedgerEntriesAPIResendWebhookEventRequest) (*WebhookEventResendContainerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WebhookEventResendContainerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LedgerEntriesAPIService.ResendWebhookEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhooks/{event_type}/{resource_token}"
	localVarPath = strings.Replace(localVarPath, "{"+"event_type"+"}", url.PathEscape(parameterValueToString(r.eventType, "eventType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_token"+"}", url.PathEscape(parameterValueToString(r.resourceToken, "resourceToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
