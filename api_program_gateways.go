/*
Core API

Marqeta's Core API endpoints, conveniently annotated to enable code generation (including SDKs), test cases, and documentation. Currently in beta.

API version: 3.0.19
Contact: support@marqeta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ProgramGatewaysAPIService ProgramGatewaysAPI service
type ProgramGatewaysAPIService service

type ProgramGatewaysAPICreateProgramGatewayRequest struct {
	ctx context.Context
	ApiService *ProgramGatewaysAPIService
	programGatewayCreateReq *ProgramGatewayCreateReq
}

func (r ProgramGatewaysAPICreateProgramGatewayRequest) ProgramGatewayCreateReq(programGatewayCreateReq ProgramGatewayCreateReq) ProgramGatewaysAPICreateProgramGatewayRequest {
	r.programGatewayCreateReq = &programGatewayCreateReq
	return r
}

func (r ProgramGatewaysAPICreateProgramGatewayRequest) Execute() (*ProgramGatewayResponse, *http.Response, error) {
	return r.ApiService.CreateProgramGatewayExecute(r)
}

/*
CreateProgramGateway Create Program Gateway

Create a new Credit Program Gateway.

Use this endpoint to configure your Program Gateway to receive gateway requests from Marqeta's credit platform.
You can create multiple Program Gateways, but only one can be active per credit program.

[NOTE]
To create a Program Gateway, you must have consumer or admin credentials.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProgramGatewaysAPICreateProgramGatewayRequest
*/
func (a *ProgramGatewaysAPIService) CreateProgramGateway(ctx context.Context) ProgramGatewaysAPICreateProgramGatewayRequest {
	return ProgramGatewaysAPICreateProgramGatewayRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProgramGatewayResponse
func (a *ProgramGatewaysAPIService) CreateProgramGatewayExecute(r ProgramGatewaysAPICreateProgramGatewayRequest) (*ProgramGatewayResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProgramGatewayResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProgramGatewaysAPIService.CreateProgramGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/programgateways"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.programGatewayCreateReq == nil {
		return localVarReturnValue, nil, reportError("programGatewayCreateReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.programGatewayCreateReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProgramGatewaysAPIListProgramGatewaysRequest struct {
	ctx context.Context
	ApiService *ProgramGatewaysAPIService
	count *int32
	startIndex *int32
	sortBy *string
}

// Number of program gateway resources to retrieve.
func (r ProgramGatewaysAPIListProgramGatewaysRequest) Count(count int32) ProgramGatewaysAPIListProgramGatewaysRequest {
	r.count = &count
	return r
}

// Sort order index of the first resource in the returned array.
func (r ProgramGatewaysAPIListProgramGatewaysRequest) StartIndex(startIndex int32) ProgramGatewaysAPIListProgramGatewaysRequest {
	r.startIndex = &startIndex
	return r
}

// Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
func (r ProgramGatewaysAPIListProgramGatewaysRequest) SortBy(sortBy string) ProgramGatewaysAPIListProgramGatewaysRequest {
	r.sortBy = &sortBy
	return r
}

func (r ProgramGatewaysAPIListProgramGatewaysRequest) Execute() (*ProgramGatewayPage, *http.Response, error) {
	return r.ApiService.ListProgramGatewaysExecute(r)
}

/*
ListProgramGateways List Program Gateways

Retrieve an array of existing Credit Program Gateways.

This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProgramGatewaysAPIListProgramGatewaysRequest
*/
func (a *ProgramGatewaysAPIService) ListProgramGateways(ctx context.Context) ProgramGatewaysAPIListProgramGatewaysRequest {
	return ProgramGatewaysAPIListProgramGatewaysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProgramGatewayPage
func (a *ProgramGatewaysAPIService) ListProgramGatewaysExecute(r ProgramGatewaysAPIListProgramGatewaysRequest) (*ProgramGatewayPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProgramGatewayPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProgramGatewaysAPIService.ListProgramGateways")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/programgateways"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-lastModifiedTime"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProgramGatewaysAPIRetrieveProgramGatewayRequest struct {
	ctx context.Context
	ApiService *ProgramGatewaysAPIService
	token string
}

func (r ProgramGatewaysAPIRetrieveProgramGatewayRequest) Execute() (*ProgramGatewayResponse, *http.Response, error) {
	return r.ApiService.RetrieveProgramGatewayExecute(r)
}

/*
RetrieveProgramGateway Retrieve Program Gateway

Retrieve an existing Credit Program Gateway.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the Program Gateway to retrieve.  Send a `GET` request to `/credit/programgateways` to retrieve existing Program Gateway tokens.
 @return ProgramGatewaysAPIRetrieveProgramGatewayRequest
*/
func (a *ProgramGatewaysAPIService) RetrieveProgramGateway(ctx context.Context, token string) ProgramGatewaysAPIRetrieveProgramGatewayRequest {
	return ProgramGatewaysAPIRetrieveProgramGatewayRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return ProgramGatewayResponse
func (a *ProgramGatewaysAPIService) RetrieveProgramGatewayExecute(r ProgramGatewaysAPIRetrieveProgramGatewayRequest) (*ProgramGatewayResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProgramGatewayResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProgramGatewaysAPIService.RetrieveProgramGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/programgateways/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProgramGatewaysAPIUpdateProgramGatewayRequest struct {
	ctx context.Context
	ApiService *ProgramGatewaysAPIService
	token string
	programGatewayUpdateReq *ProgramGatewayUpdateReq
}

func (r ProgramGatewaysAPIUpdateProgramGatewayRequest) ProgramGatewayUpdateReq(programGatewayUpdateReq ProgramGatewayUpdateReq) ProgramGatewaysAPIUpdateProgramGatewayRequest {
	r.programGatewayUpdateReq = &programGatewayUpdateReq
	return r
}

func (r ProgramGatewaysAPIUpdateProgramGatewayRequest) Execute() (*ProgramGatewayResponse, *http.Response, error) {
	return r.ApiService.UpdateProgramGatewayExecute(r)
}

/*
UpdateProgramGateway Update Program Gateway

Update an existing Credit Program Gateway.

You may want to update a Program Gateway if you are switching it to active or inactive, updating the URL, username, or password, and more.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the Program Gateway to update.
 @return ProgramGatewaysAPIUpdateProgramGatewayRequest
*/
func (a *ProgramGatewaysAPIService) UpdateProgramGateway(ctx context.Context, token string) ProgramGatewaysAPIUpdateProgramGatewayRequest {
	return ProgramGatewaysAPIUpdateProgramGatewayRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return ProgramGatewayResponse
func (a *ProgramGatewaysAPIService) UpdateProgramGatewayExecute(r ProgramGatewaysAPIUpdateProgramGatewayRequest) (*ProgramGatewayResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProgramGatewayResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProgramGatewaysAPIService.UpdateProgramGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/programgateways/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.programGatewayUpdateReq == nil {
		return localVarReturnValue, nil, reportError("programGatewayUpdateReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.programGatewayUpdateReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
