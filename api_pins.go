/*
Core API

Marqeta's Core API endpoints, conveniently annotated to enable code generation (including SDKs), test cases, and documentation. Currently in beta.

API version: 3.0.19
Contact: support@marqeta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// PINsAPIService PINsAPI service
type PINsAPIService service

type PINsAPIPostPinsControltokenRequest struct {
	ctx context.Context
	ApiService *PINsAPIService
	controlTokenRequest *ControlTokenRequest
}

func (r PINsAPIPostPinsControltokenRequest) ControlTokenRequest(controlTokenRequest ControlTokenRequest) PINsAPIPostPinsControltokenRequest {
	r.controlTokenRequest = &controlTokenRequest
	return r
}

func (r PINsAPIPostPinsControltokenRequest) Execute() (*ControlTokenResponse, *http.Response, error) {
	return r.ApiService.PostPinsControltokenExecute(r)
}

/*
PostPinsControltoken Create PIN control token

Creates a control token necessary when creating or updating a card's personal identification number (PIN).

Creating, updating, or revealing a card's PIN is a two-step process.
You must first create the control token that is required to create the PIN, and then you create, update, or reveal the PIN itself.

The lifespan of the control token in a production environment is either five minutes or one hour from creation, depending on the token type.
If multiple tokens are requested for a single card, only the most recent one is valid.
Once redeemed, a token cannot be reused.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PINsAPIPostPinsControltokenRequest
*/
func (a *PINsAPIService) PostPinsControltoken(ctx context.Context) PINsAPIPostPinsControltokenRequest {
	return PINsAPIPostPinsControltokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ControlTokenResponse
func (a *PINsAPIService) PostPinsControltokenExecute(r PINsAPIPostPinsControltokenRequest) (*ControlTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ControlTokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PINsAPIService.PostPinsControltoken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pins/controltoken"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.controlTokenRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PINsAPIPutPinsRequest struct {
	ctx context.Context
	ApiService *PINsAPIService
	pinRequest *PinRequest
}

func (r PINsAPIPutPinsRequest) PinRequest(pinRequest PinRequest) PINsAPIPutPinsRequest {
	r.pinRequest = &pinRequest
	return r
}

func (r PINsAPIPutPinsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutPinsExecute(r)
}

/*
PutPins Create or update PIN

Creates or updates a personal identification number (PIN) for an existing card.

If you want to manage a card's PIN, first create a new control token for the card by sending a `POST` request to `/pins/controltoken`, and then use that token to update the PIN.
You must create a card before you can manage a PIN.

Unless PIN reveal functionality has been enabled for your program, you cannot retrieve a PIN that has previously been created.
If the PIN has been forgotten, you must either update the card's PIN or create a new card and PIN.

If you have enabled PIN reveal functionality for your program, you can send a `POST` request to the `/pins/reveal` endpoint to retrieve an existing PIN.
See <</core-api/pins#revealPins, Reveal PIN>> on this page for details.

[WARNING]
Sending a request to this endpoint requires PCI DSS compliance.
You must comply with PCI DSS data security requirements if you want to store, transmit, or process sensitive card data such as the cardholder's primary account number (PAN), personal identification number (PIN), and card expiration date.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PINsAPIPutPinsRequest
*/
func (a *PINsAPIService) PutPins(ctx context.Context) PINsAPIPutPinsRequest {
	return PINsAPIPutPinsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PINsAPIService) PutPinsExecute(r PINsAPIPutPinsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PINsAPIService.PutPins")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pins"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pinRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PINsAPIRevealPinsRequest struct {
	ctx context.Context
	ApiService *PINsAPIService
	pinRevealRequest *PinRevealRequest
}

func (r PINsAPIRevealPinsRequest) PinRevealRequest(pinRevealRequest PinRevealRequest) PINsAPIRevealPinsRequest {
	r.pinRevealRequest = &pinRevealRequest
	return r
}

func (r PINsAPIRevealPinsRequest) Execute() (*http.Response, error) {
	return r.ApiService.RevealPinsExecute(r)
}

/*
RevealPins Reveal PIN

Reveals the personal identification number (PIN) of an existing, active card.

*WARNING:* Only use this endpoint to access a PIN in order to reveal it to its cardholder.
Do not use this endpoint for the purpose of storing a PIN at any location.

Sending a request to this endpoint requires PCI DSS compliance.
You must comply with PCI DSS data security requirements if you want to store, transmit, or process sensitive card data such as the cardholder's primary account number (PAN), personal identification number (PIN), and card expiration date.

If you want instead to update a card's PIN, send a `PUT` request to the `/pins` endpoint.
See <</core-api/pins#putPins, Create or Update PIN>> on this page for details.

Revealing a card's PIN is a two-step process.
You must first create a new control token for the card by sending a `POST` request to `/pins/controltoken`, and then use that token to reveal the PIN.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PINsAPIRevealPinsRequest
*/
func (a *PINsAPIService) RevealPins(ctx context.Context) PINsAPIRevealPinsRequest {
	return PINsAPIRevealPinsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PINsAPIService) RevealPinsExecute(r PINsAPIRevealPinsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PINsAPIService.RevealPins")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pins/reveal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pinRevealRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
