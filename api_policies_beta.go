/*
Core API

Marqeta's Core API endpoints, conveniently annotated to enable code generation (including SDKs), test cases, and documentation. Currently in beta.

API version: 3.0.19
Contact: support@marqeta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PoliciesBetaAPIService PoliciesBetaAPI service
type PoliciesBetaAPIService service

type PoliciesBetaAPICloneAprPolicyRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	token string
}

func (r PoliciesBetaAPICloneAprPolicyRequest) Execute() (*PolicyAprResponse, *http.Response, error) {
	return r.ApiService.CloneAprPolicyExecute(r)
}

/*
CloneAprPolicy Clone APR policy

Create a new annual percentage rate (APR) policy based on an existing APR policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the APR policy to clone.  Send a `GET` request to `/policies/aprs` to retrieve existing APR policy tokens.
 @return PoliciesBetaAPICloneAprPolicyRequest
*/
func (a *PoliciesBetaAPIService) CloneAprPolicy(ctx context.Context, token string) PoliciesBetaAPICloneAprPolicyRequest {
	return PoliciesBetaAPICloneAprPolicyRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return PolicyAprResponse
func (a *PoliciesBetaAPIService) CloneAprPolicyExecute(r PoliciesBetaAPICloneAprPolicyRequest) (*PolicyAprResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyAprResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.CloneAprPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/aprs/{token}/clone"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPICloneDocumentPolicyRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	token string
}

func (r PoliciesBetaAPICloneDocumentPolicyRequest) Execute() (*PolicyDocumentResponse, *http.Response, error) {
	return r.ApiService.CloneDocumentPolicyExecute(r)
}

/*
CloneDocumentPolicy Clone document policy

Create a new document policy based on an existing document policy.
A document policy consists of all the pre- and post-application disclosures and credit program documents known as assets and templates.
Assets contain finalized values after a bundle is created; templates do not contain finalized values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the document policy to clone.  Send a `GET` request to `/policies/documents` to retrieve existing document policy tokens.
 @return PoliciesBetaAPICloneDocumentPolicyRequest
*/
func (a *PoliciesBetaAPIService) CloneDocumentPolicy(ctx context.Context, token string) PoliciesBetaAPICloneDocumentPolicyRequest {
	return PoliciesBetaAPICloneDocumentPolicyRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return PolicyDocumentResponse
func (a *PoliciesBetaAPIService) CloneDocumentPolicyExecute(r PoliciesBetaAPICloneDocumentPolicyRequest) (*PolicyDocumentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyDocumentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.CloneDocumentPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/documents/{token}/clone"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPICloneFeePolicyRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	token string
}

func (r PoliciesBetaAPICloneFeePolicyRequest) Execute() (*PolicyFeeResponse, *http.Response, error) {
	return r.ApiService.CloneFeePolicyExecute(r)
}

/*
CloneFeePolicy Clone fee policy

Create a new fee policy based on an existing fee policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the fee policy to clone.  Send a `GET` request to `/policies/fee` to retrieve existing fee policy tokens.
 @return PoliciesBetaAPICloneFeePolicyRequest
*/
func (a *PoliciesBetaAPIService) CloneFeePolicy(ctx context.Context, token string) PoliciesBetaAPICloneFeePolicyRequest {
	return PoliciesBetaAPICloneFeePolicyRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return PolicyFeeResponse
func (a *PoliciesBetaAPIService) CloneFeePolicyExecute(r PoliciesBetaAPICloneFeePolicyRequest) (*PolicyFeeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyFeeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.CloneFeePolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/fees/{token}/clone"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPICloneProductPolicyRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	token string
}

func (r PoliciesBetaAPICloneProductPolicyRequest) Execute() (*PolicyProductResponse, *http.Response, error) {
	return r.ApiService.CloneProductPolicyExecute(r)
}

/*
CloneProductPolicy Clone credit product policy

Create a new credit product policy based on an existing credit product policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the credit product policy to clone.  Send a `GET` request to `/policies/products` to retrieve existing credit product policy tokens.
 @return PoliciesBetaAPICloneProductPolicyRequest
*/
func (a *PoliciesBetaAPIService) CloneProductPolicy(ctx context.Context, token string) PoliciesBetaAPICloneProductPolicyRequest {
	return PoliciesBetaAPICloneProductPolicyRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return PolicyProductResponse
func (a *PoliciesBetaAPIService) CloneProductPolicyExecute(r PoliciesBetaAPICloneProductPolicyRequest) (*PolicyProductResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyProductResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.CloneProductPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/products/{token}/clone"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPICloneRewardPolicyRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	token string
}

func (r PoliciesBetaAPICloneRewardPolicyRequest) Execute() (*PolicyRewardResponse, *http.Response, error) {
	return r.ApiService.CloneRewardPolicyExecute(r)
}

/*
CloneRewardPolicy Clone reward policy

Create a new reward policy based on existing reward policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the reward policy to clone.  Send a `GET` request to `/policies/rewards` to retrieve existing reward policy tokens.
 @return PoliciesBetaAPICloneRewardPolicyRequest
*/
func (a *PoliciesBetaAPIService) CloneRewardPolicy(ctx context.Context, token string) PoliciesBetaAPICloneRewardPolicyRequest {
	return PoliciesBetaAPICloneRewardPolicyRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return PolicyRewardResponse
func (a *PoliciesBetaAPIService) CloneRewardPolicyExecute(r PoliciesBetaAPICloneRewardPolicyRequest) (*PolicyRewardResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyRewardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.CloneRewardPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/rewards/{token}/clone"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPICreateAprPolicyRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	policyAprCreateReq *PolicyAprCreateReq
}

func (r PoliciesBetaAPICreateAprPolicyRequest) PolicyAprCreateReq(policyAprCreateReq PolicyAprCreateReq) PoliciesBetaAPICreateAprPolicyRequest {
	r.policyAprCreateReq = &policyAprCreateReq
	return r
}

func (r PoliciesBetaAPICreateAprPolicyRequest) Execute() (*PolicyAprResponse, *http.Response, error) {
	return r.ApiService.CreateAprPolicyExecute(r)
}

/*
CreateAprPolicy Create APR policy

Create a new annual percentage rate (APR) policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PoliciesBetaAPICreateAprPolicyRequest
*/
func (a *PoliciesBetaAPIService) CreateAprPolicy(ctx context.Context) PoliciesBetaAPICreateAprPolicyRequest {
	return PoliciesBetaAPICreateAprPolicyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PolicyAprResponse
func (a *PoliciesBetaAPIService) CreateAprPolicyExecute(r PoliciesBetaAPICreateAprPolicyRequest) (*PolicyAprResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyAprResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.CreateAprPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/aprs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policyAprCreateReq == nil {
		return localVarReturnValue, nil, reportError("policyAprCreateReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policyAprCreateReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPICreateDocumentPolicyRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	policyDocumentCreateReq *PolicyDocumentCreateReq
}

func (r PoliciesBetaAPICreateDocumentPolicyRequest) PolicyDocumentCreateReq(policyDocumentCreateReq PolicyDocumentCreateReq) PoliciesBetaAPICreateDocumentPolicyRequest {
	r.policyDocumentCreateReq = &policyDocumentCreateReq
	return r
}

func (r PoliciesBetaAPICreateDocumentPolicyRequest) Execute() (*PolicyDocumentResponse, *http.Response, error) {
	return r.ApiService.CreateDocumentPolicyExecute(r)
}

/*
CreateDocumentPolicy Create document policy

Create a new document policy, which consists of all the pre- and post-application disclosures and credit program documents known as assets and templates.
Assets contain finalized values after a bundle is created; templates do not contain finalized values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PoliciesBetaAPICreateDocumentPolicyRequest
*/
func (a *PoliciesBetaAPIService) CreateDocumentPolicy(ctx context.Context) PoliciesBetaAPICreateDocumentPolicyRequest {
	return PoliciesBetaAPICreateDocumentPolicyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PolicyDocumentResponse
func (a *PoliciesBetaAPIService) CreateDocumentPolicyExecute(r PoliciesBetaAPICreateDocumentPolicyRequest) (*PolicyDocumentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyDocumentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.CreateDocumentPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/documents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policyDocumentCreateReq == nil {
		return localVarReturnValue, nil, reportError("policyDocumentCreateReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policyDocumentCreateReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPICreateFeePolicyRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	policyFeeCreateReq *PolicyFeeCreateReq
}

func (r PoliciesBetaAPICreateFeePolicyRequest) PolicyFeeCreateReq(policyFeeCreateReq PolicyFeeCreateReq) PoliciesBetaAPICreateFeePolicyRequest {
	r.policyFeeCreateReq = &policyFeeCreateReq
	return r
}

func (r PoliciesBetaAPICreateFeePolicyRequest) Execute() (*PolicyFeeResponse, *http.Response, error) {
	return r.ApiService.CreateFeePolicyExecute(r)
}

/*
CreateFeePolicy Create fee policy

Create a new fee policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PoliciesBetaAPICreateFeePolicyRequest
*/
func (a *PoliciesBetaAPIService) CreateFeePolicy(ctx context.Context) PoliciesBetaAPICreateFeePolicyRequest {
	return PoliciesBetaAPICreateFeePolicyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PolicyFeeResponse
func (a *PoliciesBetaAPIService) CreateFeePolicyExecute(r PoliciesBetaAPICreateFeePolicyRequest) (*PolicyFeeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyFeeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.CreateFeePolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/fees"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policyFeeCreateReq == nil {
		return localVarReturnValue, nil, reportError("policyFeeCreateReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policyFeeCreateReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPICreateProductPolicyRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	policyProductCreateReq *PolicyProductCreateReq
}

func (r PoliciesBetaAPICreateProductPolicyRequest) PolicyProductCreateReq(policyProductCreateReq PolicyProductCreateReq) PoliciesBetaAPICreateProductPolicyRequest {
	r.policyProductCreateReq = &policyProductCreateReq
	return r
}

func (r PoliciesBetaAPICreateProductPolicyRequest) Execute() (*PolicyProductResponse, *http.Response, error) {
	return r.ApiService.CreateProductPolicyExecute(r)
}

/*
CreateProductPolicy Create credit product policy

Create a new credit product policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PoliciesBetaAPICreateProductPolicyRequest
*/
func (a *PoliciesBetaAPIService) CreateProductPolicy(ctx context.Context) PoliciesBetaAPICreateProductPolicyRequest {
	return PoliciesBetaAPICreateProductPolicyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PolicyProductResponse
func (a *PoliciesBetaAPIService) CreateProductPolicyExecute(r PoliciesBetaAPICreateProductPolicyRequest) (*PolicyProductResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyProductResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.CreateProductPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/products"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policyProductCreateReq == nil {
		return localVarReturnValue, nil, reportError("policyProductCreateReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policyProductCreateReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPICreateRewardPolicyRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	policyRewardReq *PolicyRewardReq
}

func (r PoliciesBetaAPICreateRewardPolicyRequest) PolicyRewardReq(policyRewardReq PolicyRewardReq) PoliciesBetaAPICreateRewardPolicyRequest {
	r.policyRewardReq = &policyRewardReq
	return r
}

func (r PoliciesBetaAPICreateRewardPolicyRequest) Execute() (*PolicyRewardResponse, *http.Response, error) {
	return r.ApiService.CreateRewardPolicyExecute(r)
}

/*
CreateRewardPolicy Create reward policy

Create a new reward policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PoliciesBetaAPICreateRewardPolicyRequest
*/
func (a *PoliciesBetaAPIService) CreateRewardPolicy(ctx context.Context) PoliciesBetaAPICreateRewardPolicyRequest {
	return PoliciesBetaAPICreateRewardPolicyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PolicyRewardResponse
func (a *PoliciesBetaAPIService) CreateRewardPolicyExecute(r PoliciesBetaAPICreateRewardPolicyRequest) (*PolicyRewardResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyRewardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.CreateRewardPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/rewards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policyRewardReq == nil {
		return localVarReturnValue, nil, reportError("policyRewardReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policyRewardReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPIGetAprPoliciesRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	count *int32
	startIndex *int32
	sortBy *string
}

// Number of APR policy resources to retrieve.
func (r PoliciesBetaAPIGetAprPoliciesRequest) Count(count int32) PoliciesBetaAPIGetAprPoliciesRequest {
	r.count = &count
	return r
}

// Sort order index of the first resource in the returned array.
func (r PoliciesBetaAPIGetAprPoliciesRequest) StartIndex(startIndex int32) PoliciesBetaAPIGetAprPoliciesRequest {
	r.startIndex = &startIndex
	return r
}

// Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;effectiveDate&#x60;, and not by the field names appearing in response bodies such as &#x60;effective_date&#x60;.
func (r PoliciesBetaAPIGetAprPoliciesRequest) SortBy(sortBy string) PoliciesBetaAPIGetAprPoliciesRequest {
	r.sortBy = &sortBy
	return r
}

func (r PoliciesBetaAPIGetAprPoliciesRequest) Execute() (*PolicyAprsPage, *http.Response, error) {
	return r.ApiService.GetAprPoliciesExecute(r)
}

/*
GetAprPolicies List APR policies

Retrieve an array of existing APR policies.

This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PoliciesBetaAPIGetAprPoliciesRequest
*/
func (a *PoliciesBetaAPIService) GetAprPolicies(ctx context.Context) PoliciesBetaAPIGetAprPoliciesRequest {
	return PoliciesBetaAPIGetAprPoliciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PolicyAprsPage
func (a *PoliciesBetaAPIService) GetAprPoliciesExecute(r PoliciesBetaAPIGetAprPoliciesRequest) (*PolicyAprsPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyAprsPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.GetAprPolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/aprs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-effectiveDate"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPIGetAprPolicyByTokenRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	token string
}

func (r PoliciesBetaAPIGetAprPolicyByTokenRequest) Execute() (*PolicyAprResponse, *http.Response, error) {
	return r.ApiService.GetAprPolicyByTokenExecute(r)
}

/*
GetAprPolicyByToken Retrieve APR policy

Retrieve a specific annual percentage rate (APR) policy.

This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the APR policy to retrieve.  Send a `GET` request to `/policies/aprs` to retrieve existing APR policy tokens.
 @return PoliciesBetaAPIGetAprPolicyByTokenRequest
*/
func (a *PoliciesBetaAPIService) GetAprPolicyByToken(ctx context.Context, token string) PoliciesBetaAPIGetAprPolicyByTokenRequest {
	return PoliciesBetaAPIGetAprPolicyByTokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return PolicyAprResponse
func (a *PoliciesBetaAPIService) GetAprPolicyByTokenExecute(r PoliciesBetaAPIGetAprPolicyByTokenRequest) (*PolicyAprResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyAprResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.GetAprPolicyByToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/aprs/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPIGetAprPolicySchedulesWithTokenRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	token string
	count *int32
	startIndex *int32
	sortBy *string
}

// Number of APR schedule resources to retrieve.
func (r PoliciesBetaAPIGetAprPolicySchedulesWithTokenRequest) Count(count int32) PoliciesBetaAPIGetAprPolicySchedulesWithTokenRequest {
	r.count = &count
	return r
}

// Sort order index of the first resource in the returned array.
func (r PoliciesBetaAPIGetAprPolicySchedulesWithTokenRequest) StartIndex(startIndex int32) PoliciesBetaAPIGetAprPolicySchedulesWithTokenRequest {
	r.startIndex = &startIndex
	return r
}

// Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
func (r PoliciesBetaAPIGetAprPolicySchedulesWithTokenRequest) SortBy(sortBy string) PoliciesBetaAPIGetAprPolicySchedulesWithTokenRequest {
	r.sortBy = &sortBy
	return r
}

func (r PoliciesBetaAPIGetAprPolicySchedulesWithTokenRequest) Execute() (*PolicyAprsPage, *http.Response, error) {
	return r.ApiService.GetAprPolicySchedulesWithTokenExecute(r)
}

/*
GetAprPolicySchedulesWithToken List APR schedules

Retrieve an array of the historic annual percentage rate (APR) schedules on a specific APR policy.

This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the APR policy on which to retrieve APR schedules.  Send a `GET` request to `/policies/aprs` to retrieve existing product policy tokens.
 @return PoliciesBetaAPIGetAprPolicySchedulesWithTokenRequest
*/
func (a *PoliciesBetaAPIService) GetAprPolicySchedulesWithToken(ctx context.Context, token string) PoliciesBetaAPIGetAprPolicySchedulesWithTokenRequest {
	return PoliciesBetaAPIGetAprPolicySchedulesWithTokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return PolicyAprsPage
func (a *PoliciesBetaAPIService) GetAprPolicySchedulesWithTokenExecute(r PoliciesBetaAPIGetAprPolicySchedulesWithTokenRequest) (*PolicyAprsPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyAprsPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.GetAprPolicySchedulesWithToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/aprs/{token}/schedule"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-lastModifiedTime"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPIGetFeePoliciesRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	count *int32
	startIndex *int32
	sortBy *string
}

// Number of fee policy resources to retrieve.
func (r PoliciesBetaAPIGetFeePoliciesRequest) Count(count int32) PoliciesBetaAPIGetFeePoliciesRequest {
	r.count = &count
	return r
}

// Sort order index of the first resource in the returned array.
func (r PoliciesBetaAPIGetFeePoliciesRequest) StartIndex(startIndex int32) PoliciesBetaAPIGetFeePoliciesRequest {
	r.startIndex = &startIndex
	return r
}

// Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
func (r PoliciesBetaAPIGetFeePoliciesRequest) SortBy(sortBy string) PoliciesBetaAPIGetFeePoliciesRequest {
	r.sortBy = &sortBy
	return r
}

func (r PoliciesBetaAPIGetFeePoliciesRequest) Execute() (*PolicyFeesPage, *http.Response, error) {
	return r.ApiService.GetFeePoliciesExecute(r)
}

/*
GetFeePolicies List fee policies

Retrieve an array of existing fee policies.

This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PoliciesBetaAPIGetFeePoliciesRequest
*/
func (a *PoliciesBetaAPIService) GetFeePolicies(ctx context.Context) PoliciesBetaAPIGetFeePoliciesRequest {
	return PoliciesBetaAPIGetFeePoliciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PolicyFeesPage
func (a *PoliciesBetaAPIService) GetFeePoliciesExecute(r PoliciesBetaAPIGetFeePoliciesRequest) (*PolicyFeesPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyFeesPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.GetFeePolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/fees"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-lastModifiedTime"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPIGetFeePolicyByTokenRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	token string
}

func (r PoliciesBetaAPIGetFeePolicyByTokenRequest) Execute() (*PolicyFeeResponse, *http.Response, error) {
	return r.ApiService.GetFeePolicyByTokenExecute(r)
}

/*
GetFeePolicyByToken Retrieve fee policy

Retrieve a specific fee policy.

This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the fee policy to retrieve.  Send a `GET` request to `/policies/fee` to retrieve existing fee policy tokens.
 @return PoliciesBetaAPIGetFeePolicyByTokenRequest
*/
func (a *PoliciesBetaAPIService) GetFeePolicyByToken(ctx context.Context, token string) PoliciesBetaAPIGetFeePolicyByTokenRequest {
	return PoliciesBetaAPIGetFeePolicyByTokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return PolicyFeeResponse
func (a *PoliciesBetaAPIService) GetFeePolicyByTokenExecute(r PoliciesBetaAPIGetFeePolicyByTokenRequest) (*PolicyFeeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyFeeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.GetFeePolicyByToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/fees/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPIListDocumentPoliciesRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	count *int32
	startIndex *int32
	sortBy *string
}

// Number of document policy resources to retrieve.
func (r PoliciesBetaAPIListDocumentPoliciesRequest) Count(count int32) PoliciesBetaAPIListDocumentPoliciesRequest {
	r.count = &count
	return r
}

// Sort order index of the first resource in the returned array.
func (r PoliciesBetaAPIListDocumentPoliciesRequest) StartIndex(startIndex int32) PoliciesBetaAPIListDocumentPoliciesRequest {
	r.startIndex = &startIndex
	return r
}

// Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
func (r PoliciesBetaAPIListDocumentPoliciesRequest) SortBy(sortBy string) PoliciesBetaAPIListDocumentPoliciesRequest {
	r.sortBy = &sortBy
	return r
}

func (r PoliciesBetaAPIListDocumentPoliciesRequest) Execute() (*PoliciesDocumentPage, *http.Response, error) {
	return r.ApiService.ListDocumentPoliciesExecute(r)
}

/*
ListDocumentPolicies List document policies

Retrieve an array of existing document policies.
A document policy consists of all the pre- and post-application disclosures and credit program documents known as assets and templates.
Assets contain finalized values after a bundle is created; templates do not contain finalized values.

This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PoliciesBetaAPIListDocumentPoliciesRequest
*/
func (a *PoliciesBetaAPIService) ListDocumentPolicies(ctx context.Context) PoliciesBetaAPIListDocumentPoliciesRequest {
	return PoliciesBetaAPIListDocumentPoliciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PoliciesDocumentPage
func (a *PoliciesBetaAPIService) ListDocumentPoliciesExecute(r PoliciesBetaAPIListDocumentPoliciesRequest) (*PoliciesDocumentPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PoliciesDocumentPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.ListDocumentPolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/documents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-lastModifiedTime"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPIListProductPoliciesRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	count *int32
	startIndex *int32
	sortBy *string
}

// Number of product policy resources to retrieve.
func (r PoliciesBetaAPIListProductPoliciesRequest) Count(count int32) PoliciesBetaAPIListProductPoliciesRequest {
	r.count = &count
	return r
}

// Sort order index of the first resource in the returned array.
func (r PoliciesBetaAPIListProductPoliciesRequest) StartIndex(startIndex int32) PoliciesBetaAPIListProductPoliciesRequest {
	r.startIndex = &startIndex
	return r
}

// Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
func (r PoliciesBetaAPIListProductPoliciesRequest) SortBy(sortBy string) PoliciesBetaAPIListProductPoliciesRequest {
	r.sortBy = &sortBy
	return r
}

func (r PoliciesBetaAPIListProductPoliciesRequest) Execute() (*PoliciesProductPage, *http.Response, error) {
	return r.ApiService.ListProductPoliciesExecute(r)
}

/*
ListProductPolicies List credit product policies

Retrieve an array of existing credit product policies.

This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PoliciesBetaAPIListProductPoliciesRequest
*/
func (a *PoliciesBetaAPIService) ListProductPolicies(ctx context.Context) PoliciesBetaAPIListProductPoliciesRequest {
	return PoliciesBetaAPIListProductPoliciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PoliciesProductPage
func (a *PoliciesBetaAPIService) ListProductPoliciesExecute(r PoliciesBetaAPIListProductPoliciesRequest) (*PoliciesProductPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PoliciesProductPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.ListProductPolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/products"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-lastModifiedTime"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPIListRewardPoliciesRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	count *int32
	startIndex *int32
	sortBy *string
}

// Number of reward policy resources to retrieve.
func (r PoliciesBetaAPIListRewardPoliciesRequest) Count(count int32) PoliciesBetaAPIListRewardPoliciesRequest {
	r.count = &count
	return r
}

// Sort order index of the first resource in the returned array.
func (r PoliciesBetaAPIListRewardPoliciesRequest) StartIndex(startIndex int32) PoliciesBetaAPIListRewardPoliciesRequest {
	r.startIndex = &startIndex
	return r
}

// Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
func (r PoliciesBetaAPIListRewardPoliciesRequest) SortBy(sortBy string) PoliciesBetaAPIListRewardPoliciesRequest {
	r.sortBy = &sortBy
	return r
}

func (r PoliciesBetaAPIListRewardPoliciesRequest) Execute() (*PolicyRewardPage, *http.Response, error) {
	return r.ApiService.ListRewardPoliciesExecute(r)
}

/*
ListRewardPolicies List reward policies

Retrieve an array of reward policies.

This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PoliciesBetaAPIListRewardPoliciesRequest
*/
func (a *PoliciesBetaAPIService) ListRewardPolicies(ctx context.Context) PoliciesBetaAPIListRewardPoliciesRequest {
	return PoliciesBetaAPIListRewardPoliciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PolicyRewardPage
func (a *PoliciesBetaAPIService) ListRewardPoliciesExecute(r PoliciesBetaAPIListRewardPoliciesRequest) (*PolicyRewardPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyRewardPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.ListRewardPolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/rewards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-lastModifiedTime"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPIRetrieveDocumentPolicyRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	token string
}

func (r PoliciesBetaAPIRetrieveDocumentPolicyRequest) Execute() (*PolicyDocumentResponse, *http.Response, error) {
	return r.ApiService.RetrieveDocumentPolicyExecute(r)
}

/*
RetrieveDocumentPolicy Retrieve document policy

Retrieve a specific document policy, which consists of all the pre- and post-application disclosures and credit program documents known as assets and templates.
Assets contain finalized values after a bundle is created; templates do not contain finalized values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the document policy to retrieve.  Send a `GET` request to `/policies/documents` to retrieve existing document policy tokens.
 @return PoliciesBetaAPIRetrieveDocumentPolicyRequest
*/
func (a *PoliciesBetaAPIService) RetrieveDocumentPolicy(ctx context.Context, token string) PoliciesBetaAPIRetrieveDocumentPolicyRequest {
	return PoliciesBetaAPIRetrieveDocumentPolicyRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return PolicyDocumentResponse
func (a *PoliciesBetaAPIService) RetrieveDocumentPolicyExecute(r PoliciesBetaAPIRetrieveDocumentPolicyRequest) (*PolicyDocumentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyDocumentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.RetrieveDocumentPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/documents/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPIRetrieveProductPolicyRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	token string
}

func (r PoliciesBetaAPIRetrieveProductPolicyRequest) Execute() (*PolicyProductResponse, *http.Response, error) {
	return r.ApiService.RetrieveProductPolicyExecute(r)
}

/*
RetrieveProductPolicy Retrieve credit product policy

Retrieve a specific credit product policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the credit product policy to retrieve.  Send a `GET` request to `/policies/products` to retrieve existing credit product policy tokens.
 @return PoliciesBetaAPIRetrieveProductPolicyRequest
*/
func (a *PoliciesBetaAPIService) RetrieveProductPolicy(ctx context.Context, token string) PoliciesBetaAPIRetrieveProductPolicyRequest {
	return PoliciesBetaAPIRetrieveProductPolicyRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return PolicyProductResponse
func (a *PoliciesBetaAPIService) RetrieveProductPolicyExecute(r PoliciesBetaAPIRetrieveProductPolicyRequest) (*PolicyProductResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyProductResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.RetrieveProductPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/products/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPIRetrieveRewardPolicyRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	token string
}

func (r PoliciesBetaAPIRetrieveRewardPolicyRequest) Execute() (*PolicyRewardResponse, *http.Response, error) {
	return r.ApiService.RetrieveRewardPolicyExecute(r)
}

/*
RetrieveRewardPolicy Retrieve reward policy

Retrieve a reward policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the reward policy to retrieve.  Send a `GET` request to `/policies/rewards` to retrieve existing reward policy tokens.
 @return PoliciesBetaAPIRetrieveRewardPolicyRequest
*/
func (a *PoliciesBetaAPIService) RetrieveRewardPolicy(ctx context.Context, token string) PoliciesBetaAPIRetrieveRewardPolicyRequest {
	return PoliciesBetaAPIRetrieveRewardPolicyRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return PolicyRewardResponse
func (a *PoliciesBetaAPIService) RetrieveRewardPolicyExecute(r PoliciesBetaAPIRetrieveRewardPolicyRequest) (*PolicyRewardResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyRewardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.RetrieveRewardPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/rewards/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPIUpdateAprPolicyWithTokenRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	token string
	policyAprUpdateReq *PolicyAprUpdateReq
}

func (r PoliciesBetaAPIUpdateAprPolicyWithTokenRequest) PolicyAprUpdateReq(policyAprUpdateReq PolicyAprUpdateReq) PoliciesBetaAPIUpdateAprPolicyWithTokenRequest {
	r.policyAprUpdateReq = &policyAprUpdateReq
	return r
}

func (r PoliciesBetaAPIUpdateAprPolicyWithTokenRequest) Execute() (*PolicyAprResponse, *http.Response, error) {
	return r.ApiService.UpdateAprPolicyWithTokenExecute(r)
}

/*
UpdateAprPolicyWithToken Update APR policy

Update a specific APR policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the APR policy to update.  Send a `GET` request to `/policies/aprs` to retrieve existing APR policy tokens.
 @return PoliciesBetaAPIUpdateAprPolicyWithTokenRequest
*/
func (a *PoliciesBetaAPIService) UpdateAprPolicyWithToken(ctx context.Context, token string) PoliciesBetaAPIUpdateAprPolicyWithTokenRequest {
	return PoliciesBetaAPIUpdateAprPolicyWithTokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return PolicyAprResponse
func (a *PoliciesBetaAPIService) UpdateAprPolicyWithTokenExecute(r PoliciesBetaAPIUpdateAprPolicyWithTokenRequest) (*PolicyAprResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyAprResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.UpdateAprPolicyWithToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/aprs/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policyAprUpdateReq == nil {
		return localVarReturnValue, nil, reportError("policyAprUpdateReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policyAprUpdateReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPIUpdateDocumentPolicyRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	token string
	policyDocumentUpdateReq *PolicyDocumentUpdateReq
}

func (r PoliciesBetaAPIUpdateDocumentPolicyRequest) PolicyDocumentUpdateReq(policyDocumentUpdateReq PolicyDocumentUpdateReq) PoliciesBetaAPIUpdateDocumentPolicyRequest {
	r.policyDocumentUpdateReq = &policyDocumentUpdateReq
	return r
}

func (r PoliciesBetaAPIUpdateDocumentPolicyRequest) Execute() (*PolicyDocumentResponse, *http.Response, error) {
	return r.ApiService.UpdateDocumentPolicyExecute(r)
}

/*
UpdateDocumentPolicy Update document policy

Update a specific document policy, which consists of all the pre- and post-application disclosures and credit program documents known as assets and templates.
Assets contain finalized values after a bundle is created; templates do not contain finalized values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the document policy to update.  Send a `GET` request to `/policies/documents` to retrieve existing document policy tokens.
 @return PoliciesBetaAPIUpdateDocumentPolicyRequest
*/
func (a *PoliciesBetaAPIService) UpdateDocumentPolicy(ctx context.Context, token string) PoliciesBetaAPIUpdateDocumentPolicyRequest {
	return PoliciesBetaAPIUpdateDocumentPolicyRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return PolicyDocumentResponse
func (a *PoliciesBetaAPIService) UpdateDocumentPolicyExecute(r PoliciesBetaAPIUpdateDocumentPolicyRequest) (*PolicyDocumentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyDocumentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.UpdateDocumentPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/documents/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policyDocumentUpdateReq == nil {
		return localVarReturnValue, nil, reportError("policyDocumentUpdateReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policyDocumentUpdateReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPIUpdateFeePolicyWithTokenRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	token string
	policyFeeUpdateReq *PolicyFeeUpdateReq
}

func (r PoliciesBetaAPIUpdateFeePolicyWithTokenRequest) PolicyFeeUpdateReq(policyFeeUpdateReq PolicyFeeUpdateReq) PoliciesBetaAPIUpdateFeePolicyWithTokenRequest {
	r.policyFeeUpdateReq = &policyFeeUpdateReq
	return r
}

func (r PoliciesBetaAPIUpdateFeePolicyWithTokenRequest) Execute() (*PolicyFeeResponse, *http.Response, error) {
	return r.ApiService.UpdateFeePolicyWithTokenExecute(r)
}

/*
UpdateFeePolicyWithToken Update fee policy

Update a specific fee policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the fee policy to retrieve.  Send a `GET` request to `/policies/fee` to retrieve existing fee policy tokens.
 @return PoliciesBetaAPIUpdateFeePolicyWithTokenRequest
*/
func (a *PoliciesBetaAPIService) UpdateFeePolicyWithToken(ctx context.Context, token string) PoliciesBetaAPIUpdateFeePolicyWithTokenRequest {
	return PoliciesBetaAPIUpdateFeePolicyWithTokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return PolicyFeeResponse
func (a *PoliciesBetaAPIService) UpdateFeePolicyWithTokenExecute(r PoliciesBetaAPIUpdateFeePolicyWithTokenRequest) (*PolicyFeeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyFeeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.UpdateFeePolicyWithToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/fees/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policyFeeUpdateReq == nil {
		return localVarReturnValue, nil, reportError("policyFeeUpdateReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policyFeeUpdateReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPIUpdateProductPolicyRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	token string
	policyProductUpdateReq *PolicyProductUpdateReq
}

func (r PoliciesBetaAPIUpdateProductPolicyRequest) PolicyProductUpdateReq(policyProductUpdateReq PolicyProductUpdateReq) PoliciesBetaAPIUpdateProductPolicyRequest {
	r.policyProductUpdateReq = &policyProductUpdateReq
	return r
}

func (r PoliciesBetaAPIUpdateProductPolicyRequest) Execute() (*PolicyProductResponse, *http.Response, error) {
	return r.ApiService.UpdateProductPolicyExecute(r)
}

/*
UpdateProductPolicy Update credit product policy

Update a specific credit product policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the credit product policy to retrieve.  Send a `GET` request to `/policies/products` to retrieve existing credit product policy tokens.
 @return PoliciesBetaAPIUpdateProductPolicyRequest
*/
func (a *PoliciesBetaAPIService) UpdateProductPolicy(ctx context.Context, token string) PoliciesBetaAPIUpdateProductPolicyRequest {
	return PoliciesBetaAPIUpdateProductPolicyRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return PolicyProductResponse
func (a *PoliciesBetaAPIService) UpdateProductPolicyExecute(r PoliciesBetaAPIUpdateProductPolicyRequest) (*PolicyProductResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyProductResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.UpdateProductPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/products/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policyProductUpdateReq == nil {
		return localVarReturnValue, nil, reportError("policyProductUpdateReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policyProductUpdateReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PoliciesBetaAPIUpdateRewardPolicyRequest struct {
	ctx context.Context
	ApiService *PoliciesBetaAPIService
	token string
	policyRewardReq *PolicyRewardReq
}

func (r PoliciesBetaAPIUpdateRewardPolicyRequest) PolicyRewardReq(policyRewardReq PolicyRewardReq) PoliciesBetaAPIUpdateRewardPolicyRequest {
	r.policyRewardReq = &policyRewardReq
	return r
}

func (r PoliciesBetaAPIUpdateRewardPolicyRequest) Execute() (*PolicyRewardResponse, *http.Response, error) {
	return r.ApiService.UpdateRewardPolicyExecute(r)
}

/*
UpdateRewardPolicy Update reward policy

Update a reward policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the reward policy to update.  Send a `GET` request to `/policies/rewards` to retrieve existing reward policy tokens.
 @return PoliciesBetaAPIUpdateRewardPolicyRequest
*/
func (a *PoliciesBetaAPIService) UpdateRewardPolicy(ctx context.Context, token string) PoliciesBetaAPIUpdateRewardPolicyRequest {
	return PoliciesBetaAPIUpdateRewardPolicyRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return PolicyRewardResponse
func (a *PoliciesBetaAPIService) UpdateRewardPolicyExecute(r PoliciesBetaAPIUpdateRewardPolicyRequest) (*PolicyRewardResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyRewardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesBetaAPIService.UpdateRewardPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/rewards/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policyRewardReq == nil {
		return localVarReturnValue, nil, reportError("policyRewardReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policyRewardReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
