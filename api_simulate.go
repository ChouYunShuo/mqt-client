/*
Core API

Marqeta's Core API endpoints, conveniently annotated to enable code generation (including SDKs), test cases, and documentation. Currently in beta.

API version: 3.0.19
Contact: support@marqeta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// SimulateAPIService SimulateAPI service
type SimulateAPIService service

type SimulateAPIPostSimulateAuthorizationRequest struct {
	ctx context.Context
	ApiService *SimulateAPIService
	authRequestModel *AuthRequestModel
}

func (r SimulateAPIPostSimulateAuthorizationRequest) AuthRequestModel(authRequestModel AuthRequestModel) SimulateAPIPostSimulateAuthorizationRequest {
	r.authRequestModel = &authRequestModel
	return r
}

func (r SimulateAPIPostSimulateAuthorizationRequest) Execute() (*SimulationResponseModel, *http.Response, error) {
	return r.ApiService.PostSimulateAuthorizationExecute(r)
}

/*
PostSimulateAuthorization Simulates an authorization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SimulateAPIPostSimulateAuthorizationRequest
*/
func (a *SimulateAPIService) PostSimulateAuthorization(ctx context.Context) SimulateAPIPostSimulateAuthorizationRequest {
	return SimulateAPIPostSimulateAuthorizationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SimulationResponseModel
func (a *SimulateAPIService) PostSimulateAuthorizationExecute(r SimulateAPIPostSimulateAuthorizationRequest) (*SimulationResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimulationResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulateAPIService.PostSimulateAuthorization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulate/authorization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authRequestModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SimulateAPIPostSimulateAuthorizationAdviceRequest struct {
	ctx context.Context
	ApiService *SimulateAPIService
	authorizationAdviceModel *AuthorizationAdviceModel
}

func (r SimulateAPIPostSimulateAuthorizationAdviceRequest) AuthorizationAdviceModel(authorizationAdviceModel AuthorizationAdviceModel) SimulateAPIPostSimulateAuthorizationAdviceRequest {
	r.authorizationAdviceModel = &authorizationAdviceModel
	return r
}

func (r SimulateAPIPostSimulateAuthorizationAdviceRequest) Execute() (*SimulationResponseModel, *http.Response, error) {
	return r.ApiService.PostSimulateAuthorizationAdviceExecute(r)
}

/*
PostSimulateAuthorizationAdvice Simulates an authorization advice transaction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SimulateAPIPostSimulateAuthorizationAdviceRequest
*/
func (a *SimulateAPIService) PostSimulateAuthorizationAdvice(ctx context.Context) SimulateAPIPostSimulateAuthorizationAdviceRequest {
	return SimulateAPIPostSimulateAuthorizationAdviceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SimulationResponseModel
func (a *SimulateAPIService) PostSimulateAuthorizationAdviceExecute(r SimulateAPIPostSimulateAuthorizationAdviceRequest) (*SimulationResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimulationResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulateAPIService.PostSimulateAuthorizationAdvice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulate/authorization/advice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationAdviceModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SimulateAPIPostSimulateClearingRequest struct {
	ctx context.Context
	ApiService *SimulateAPIService
	clearingModel *ClearingModel
}

func (r SimulateAPIPostSimulateClearingRequest) ClearingModel(clearingModel ClearingModel) SimulateAPIPostSimulateClearingRequest {
	r.clearingModel = &clearingModel
	return r
}

func (r SimulateAPIPostSimulateClearingRequest) Execute() (*SimulationResponseModel, *http.Response, error) {
	return r.ApiService.PostSimulateClearingExecute(r)
}

/*
PostSimulateClearing Simulates a clearing/settlement transaction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SimulateAPIPostSimulateClearingRequest
*/
func (a *SimulateAPIService) PostSimulateClearing(ctx context.Context) SimulateAPIPostSimulateClearingRequest {
	return SimulateAPIPostSimulateClearingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SimulationResponseModel
func (a *SimulateAPIService) PostSimulateClearingExecute(r SimulateAPIPostSimulateClearingRequest) (*SimulationResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimulationResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulateAPIService.PostSimulateClearing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulate/clearing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clearingModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SimulateAPIPostSimulateDirectdepositsRequest struct {
	ctx context.Context
	ApiService *SimulateAPIService
	directDepositRequest *DirectDepositRequest
}

// Direct deposit simulate request model
func (r SimulateAPIPostSimulateDirectdepositsRequest) DirectDepositRequest(directDepositRequest DirectDepositRequest) SimulateAPIPostSimulateDirectdepositsRequest {
	r.directDepositRequest = &directDepositRequest
	return r
}

func (r SimulateAPIPostSimulateDirectdepositsRequest) Execute() (*DepositDepositResponse, *http.Response, error) {
	return r.ApiService.PostSimulateDirectdepositsExecute(r)
}

/*
PostSimulateDirectdeposits Simulates the creation of direct deposit

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SimulateAPIPostSimulateDirectdepositsRequest
*/
func (a *SimulateAPIService) PostSimulateDirectdeposits(ctx context.Context) SimulateAPIPostSimulateDirectdepositsRequest {
	return SimulateAPIPostSimulateDirectdepositsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DepositDepositResponse
func (a *SimulateAPIService) PostSimulateDirectdepositsExecute(r SimulateAPIPostSimulateDirectdepositsRequest) (*DepositDepositResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DepositDepositResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulateAPIService.PostSimulateDirectdeposits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulate/directdeposits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.directDepositRequest == nil {
		return localVarReturnValue, nil, reportError("directDepositRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.directDepositRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SimulateAPIPostSimulateFinancialRequest struct {
	ctx context.Context
	ApiService *SimulateAPIService
	financialRequestModel *FinancialRequestModel
}

// Financial request model
func (r SimulateAPIPostSimulateFinancialRequest) FinancialRequestModel(financialRequestModel FinancialRequestModel) SimulateAPIPostSimulateFinancialRequest {
	r.financialRequestModel = &financialRequestModel
	return r
}

func (r SimulateAPIPostSimulateFinancialRequest) Execute() (*SimulationResponseModel, *http.Response, error) {
	return r.ApiService.PostSimulateFinancialExecute(r)
}

/*
PostSimulateFinancial Simulates a financial request (PIN debit) transaction with optional cash back

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SimulateAPIPostSimulateFinancialRequest
*/
func (a *SimulateAPIService) PostSimulateFinancial(ctx context.Context) SimulateAPIPostSimulateFinancialRequest {
	return SimulateAPIPostSimulateFinancialRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SimulationResponseModel
func (a *SimulateAPIService) PostSimulateFinancialExecute(r SimulateAPIPostSimulateFinancialRequest) (*SimulationResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimulationResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulateAPIService.PostSimulateFinancial")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulate/financial"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.financialRequestModel == nil {
		return localVarReturnValue, nil, reportError("financialRequestModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.financialRequestModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SimulateAPIPostSimulateFinancialAdviceRequest struct {
	ctx context.Context
	ApiService *SimulateAPIService
	authorizationAdviceModel *AuthorizationAdviceModel
}

// Financial advice request model
func (r SimulateAPIPostSimulateFinancialAdviceRequest) AuthorizationAdviceModel(authorizationAdviceModel AuthorizationAdviceModel) SimulateAPIPostSimulateFinancialAdviceRequest {
	r.authorizationAdviceModel = &authorizationAdviceModel
	return r
}

func (r SimulateAPIPostSimulateFinancialAdviceRequest) Execute() (*SimulationResponseModel, *http.Response, error) {
	return r.ApiService.PostSimulateFinancialAdviceExecute(r)
}

/*
PostSimulateFinancialAdvice Simulates a financial advice transaction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SimulateAPIPostSimulateFinancialAdviceRequest
*/
func (a *SimulateAPIService) PostSimulateFinancialAdvice(ctx context.Context) SimulateAPIPostSimulateFinancialAdviceRequest {
	return SimulateAPIPostSimulateFinancialAdviceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SimulationResponseModel
func (a *SimulateAPIService) PostSimulateFinancialAdviceExecute(r SimulateAPIPostSimulateFinancialAdviceRequest) (*SimulationResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimulationResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulateAPIService.PostSimulateFinancialAdvice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulate/financial/advice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorizationAdviceModel == nil {
		return localVarReturnValue, nil, reportError("authorizationAdviceModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationAdviceModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SimulateAPIPostSimulateFinancialBalanceinquiryRequest struct {
	ctx context.Context
	ApiService *SimulateAPIService
	balanceInquiryRequestModel *BalanceInquiryRequestModel
}

// Balance inquiry request model
func (r SimulateAPIPostSimulateFinancialBalanceinquiryRequest) BalanceInquiryRequestModel(balanceInquiryRequestModel BalanceInquiryRequestModel) SimulateAPIPostSimulateFinancialBalanceinquiryRequest {
	r.balanceInquiryRequestModel = &balanceInquiryRequestModel
	return r
}

func (r SimulateAPIPostSimulateFinancialBalanceinquiryRequest) Execute() (*SimulationResponseModel, *http.Response, error) {
	return r.ApiService.PostSimulateFinancialBalanceinquiryExecute(r)
}

/*
PostSimulateFinancialBalanceinquiry Simulates a balance inquiry

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SimulateAPIPostSimulateFinancialBalanceinquiryRequest
*/
func (a *SimulateAPIService) PostSimulateFinancialBalanceinquiry(ctx context.Context) SimulateAPIPostSimulateFinancialBalanceinquiryRequest {
	return SimulateAPIPostSimulateFinancialBalanceinquiryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SimulationResponseModel
func (a *SimulateAPIService) PostSimulateFinancialBalanceinquiryExecute(r SimulateAPIPostSimulateFinancialBalanceinquiryRequest) (*SimulationResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimulationResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulateAPIService.PostSimulateFinancialBalanceinquiry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulate/financial/balanceinquiry"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.balanceInquiryRequestModel == nil {
		return localVarReturnValue, nil, reportError("balanceInquiryRequestModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.balanceInquiryRequestModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SimulateAPIPostSimulateFinancialOriginalcreditRequest struct {
	ctx context.Context
	ApiService *SimulateAPIService
	orignalcreditRequestModel *OrignalcreditRequestModel
}

// Orignal Credit request model
func (r SimulateAPIPostSimulateFinancialOriginalcreditRequest) OrignalcreditRequestModel(orignalcreditRequestModel OrignalcreditRequestModel) SimulateAPIPostSimulateFinancialOriginalcreditRequest {
	r.orignalcreditRequestModel = &orignalcreditRequestModel
	return r
}

func (r SimulateAPIPostSimulateFinancialOriginalcreditRequest) Execute() (*SimulationResponseModel, *http.Response, error) {
	return r.ApiService.PostSimulateFinancialOriginalcreditExecute(r)
}

/*
PostSimulateFinancialOriginalcredit Simulates an orignal credit transaction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SimulateAPIPostSimulateFinancialOriginalcreditRequest
*/
func (a *SimulateAPIService) PostSimulateFinancialOriginalcredit(ctx context.Context) SimulateAPIPostSimulateFinancialOriginalcreditRequest {
	return SimulateAPIPostSimulateFinancialOriginalcreditRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SimulationResponseModel
func (a *SimulateAPIService) PostSimulateFinancialOriginalcreditExecute(r SimulateAPIPostSimulateFinancialOriginalcreditRequest) (*SimulationResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimulationResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulateAPIService.PostSimulateFinancialOriginalcredit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulate/financial/originalcredit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orignalcreditRequestModel == nil {
		return localVarReturnValue, nil, reportError("orignalcreditRequestModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.orignalcreditRequestModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SimulateAPIPostSimulateFinancialWithdrawalRequest struct {
	ctx context.Context
	ApiService *SimulateAPIService
	withdrawalRequestModel *WithdrawalRequestModel
}

// ATM withdrawal request model
func (r SimulateAPIPostSimulateFinancialWithdrawalRequest) WithdrawalRequestModel(withdrawalRequestModel WithdrawalRequestModel) SimulateAPIPostSimulateFinancialWithdrawalRequest {
	r.withdrawalRequestModel = &withdrawalRequestModel
	return r
}

func (r SimulateAPIPostSimulateFinancialWithdrawalRequest) Execute() (*SimulationResponseModel, *http.Response, error) {
	return r.ApiService.PostSimulateFinancialWithdrawalExecute(r)
}

/*
PostSimulateFinancialWithdrawal Simulates an ATM withdrawal transaction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SimulateAPIPostSimulateFinancialWithdrawalRequest
*/
func (a *SimulateAPIService) PostSimulateFinancialWithdrawal(ctx context.Context) SimulateAPIPostSimulateFinancialWithdrawalRequest {
	return SimulateAPIPostSimulateFinancialWithdrawalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SimulationResponseModel
func (a *SimulateAPIService) PostSimulateFinancialWithdrawalExecute(r SimulateAPIPostSimulateFinancialWithdrawalRequest) (*SimulationResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimulationResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulateAPIService.PostSimulateFinancialWithdrawal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulate/financial/withdrawal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.withdrawalRequestModel == nil {
		return localVarReturnValue, nil, reportError("withdrawalRequestModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.withdrawalRequestModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SimulateAPIPostSimulateReversalRequest struct {
	ctx context.Context
	ApiService *SimulateAPIService
	reversalModel *ReversalModel
}

func (r SimulateAPIPostSimulateReversalRequest) ReversalModel(reversalModel ReversalModel) SimulateAPIPostSimulateReversalRequest {
	r.reversalModel = &reversalModel
	return r
}

func (r SimulateAPIPostSimulateReversalRequest) Execute() (*SimulationResponseModel, *http.Response, error) {
	return r.ApiService.PostSimulateReversalExecute(r)
}

/*
PostSimulateReversal Simulates a reversal transaction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SimulateAPIPostSimulateReversalRequest
*/
func (a *SimulateAPIService) PostSimulateReversal(ctx context.Context) SimulateAPIPostSimulateReversalRequest {
	return SimulateAPIPostSimulateReversalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SimulationResponseModel
func (a *SimulateAPIService) PostSimulateReversalExecute(r SimulateAPIPostSimulateReversalRequest) (*SimulationResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimulationResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulateAPIService.PostSimulateReversal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulate/reversal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reversalModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
