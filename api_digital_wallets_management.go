/*
Core API

Marqeta's Core API endpoints, conveniently annotated to enable code generation (including SDKs), test cases, and documentation. Currently in beta.

API version: 3.0.19
Contact: support@marqeta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DigitalWalletsManagementAPIService DigitalWalletsManagementAPI service
type DigitalWalletsManagementAPIService service

type DigitalWalletsManagementAPIGenerateApplePayWPPJWTRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	reqSysId *string
	requestForApplePayWppJWT *RequestForApplePayWppJWT
}

// Random pseudo-unique value used for troubleshooting between multiple parties.
func (r DigitalWalletsManagementAPIGenerateApplePayWPPJWTRequest) ReqSysId(reqSysId string) DigitalWalletsManagementAPIGenerateApplePayWPPJWTRequest {
	r.reqSysId = &reqSysId
	return r
}

func (r DigitalWalletsManagementAPIGenerateApplePayWPPJWTRequest) RequestForApplePayWppJWT(requestForApplePayWppJWT RequestForApplePayWppJWT) DigitalWalletsManagementAPIGenerateApplePayWPPJWTRequest {
	r.requestForApplePayWppJWT = &requestForApplePayWppJWT
	return r
}

func (r DigitalWalletsManagementAPIGenerateApplePayWPPJWTRequest) Execute() (*WebPushProvisioningApplePayJWTResponse, *http.Response, error) {
	return r.ApiService.GenerateApplePayWPPJWTExecute(r)
}

/*
GenerateApplePayWPPJWT Create request for Apple Wallet web push provisioning

[NOTE]
This endpoint is currently in beta and subject to change.
For more information, contact your Marqeta representative.

Use this endpoint to add a card to Apple Wallet via a web application.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DigitalWalletsManagementAPIGenerateApplePayWPPJWTRequest
*/
func (a *DigitalWalletsManagementAPIService) GenerateApplePayWPPJWT(ctx context.Context) DigitalWalletsManagementAPIGenerateApplePayWPPJWTRequest {
	return DigitalWalletsManagementAPIGenerateApplePayWPPJWTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WebPushProvisioningApplePayJWTResponse
func (a *DigitalWalletsManagementAPIService) GenerateApplePayWPPJWTExecute(r DigitalWalletsManagementAPIGenerateApplePayWPPJWTRequest) (*WebPushProvisioningApplePayJWTResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WebPushProvisioningApplePayJWTResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.GenerateApplePayWPPJWT")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwallets/wpp/applePayJWT"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reqSysId == nil {
		return localVarReturnValue, nil, reportError("reqSysId is required and must be specified")
	}
	if r.requestForApplePayWppJWT == nil {
		return localVarReturnValue, nil, reportError("requestForApplePayWppJWT is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "req-sys-id", r.reqSysId, "")
	// body params
	localVarPostBody = r.requestForApplePayWppJWT
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessageFromWebPushProvisioningRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessageFromWebPushProvisioningRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageFromWebPushProvisioningRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DigitalWalletsManagementAPIGetDigitalwallettokensRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	count *int32
	startIndex *int32
	fields *string
	sortBy *string
	startDate *string
	endDate *string
	panReferenceId *string
	tokenReferenceId *string
	correlationId *string
	tokenType *string
	tokenRequestorName *string
	state *string
	embed *string
}

// Number of digital wallet token resources to retrieve.
func (r DigitalWalletsManagementAPIGetDigitalwallettokensRequest) Count(count int32) DigitalWalletsManagementAPIGetDigitalwallettokensRequest {
	r.count = &count
	return r
}

// Sort order index of the first digital wallet token resource in the returned array.
func (r DigitalWalletsManagementAPIGetDigitalwallettokensRequest) StartIndex(startIndex int32) DigitalWalletsManagementAPIGetDigitalwallettokensRequest {
	r.startIndex = &startIndex
	return r
}

// Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
func (r DigitalWalletsManagementAPIGetDigitalwallettokensRequest) Fields(fields string) DigitalWalletsManagementAPIGetDigitalwallettokensRequest {
	r.fields = &fields
	return r
}

// Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
func (r DigitalWalletsManagementAPIGetDigitalwallettokensRequest) SortBy(sortBy string) DigitalWalletsManagementAPIGetDigitalwallettokensRequest {
	r.sortBy = &sortBy
	return r
}

// Date when the digital wallet token becomes active.
func (r DigitalWalletsManagementAPIGetDigitalwallettokensRequest) StartDate(startDate string) DigitalWalletsManagementAPIGetDigitalwallettokensRequest {
	r.startDate = &startDate
	return r
}

// Expiration date of the digital wallet token.
func (r DigitalWalletsManagementAPIGetDigitalwallettokensRequest) EndDate(endDate string) DigitalWalletsManagementAPIGetDigitalwallettokensRequest {
	r.endDate = &endDate
	return r
}

// Unique identifier of the digital wallet token primary account number (PAN) within the card network. This value may vary, depending on the digital wallet. For example, the &#x60;pan_reference_id&#x60; may be different in Apple Wallet and Google Wallet for the same digital wallet token.
func (r DigitalWalletsManagementAPIGetDigitalwallettokensRequest) PanReferenceId(panReferenceId string) DigitalWalletsManagementAPIGetDigitalwallettokensRequest {
	r.panReferenceId = &panReferenceId
	return r
}

// Unique identifier of the digital wallet token within the card network. The &#x60;token_reference_id&#x60; is unique at the card network level.
func (r DigitalWalletsManagementAPIGetDigitalwallettokensRequest) TokenReferenceId(tokenReferenceId string) DigitalWalletsManagementAPIGetDigitalwallettokensRequest {
	r.tokenReferenceId = &tokenReferenceId
	return r
}

// Unique value representing a tokenization request (Mastercard only).
func (r DigitalWalletsManagementAPIGetDigitalwallettokensRequest) CorrelationId(correlationId string) DigitalWalletsManagementAPIGetDigitalwallettokensRequest {
	r.correlationId = &correlationId
	return r
}

// Comma-delimited list of digital wallet token types to display.
func (r DigitalWalletsManagementAPIGetDigitalwallettokensRequest) TokenType(tokenType string) DigitalWalletsManagementAPIGetDigitalwallettokensRequest {
	r.tokenType = &tokenType
	return r
}

// Name of the token requestor within the card network.  *NOTE:* The list of example values for this field is maintained by the card networks and is subject to change.
func (r DigitalWalletsManagementAPIGetDigitalwallettokensRequest) TokenRequestorName(tokenRequestorName string) DigitalWalletsManagementAPIGetDigitalwallettokensRequest {
	r.tokenRequestorName = &tokenRequestorName
	return r
}

// Comma-delimited list of digital wallet token states to display.
func (r DigitalWalletsManagementAPIGetDigitalwallettokensRequest) State(state string) DigitalWalletsManagementAPIGetDigitalwallettokensRequest {
	r.state = &state
	return r
}

// An optional embedded user object.
func (r DigitalWalletsManagementAPIGetDigitalwallettokensRequest) Embed(embed string) DigitalWalletsManagementAPIGetDigitalwallettokensRequest {
	r.embed = &embed
	return r
}

func (r DigitalWalletsManagementAPIGetDigitalwallettokensRequest) Execute() (*DigitalWalletTokenListResponse, *http.Response, error) {
	return r.ApiService.GetDigitalwallettokensExecute(r)
}

/*
GetDigitalwallettokens List digital wallet tokens

Use this endpoint to retrieve a list of digital wallet tokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DigitalWalletsManagementAPIGetDigitalwallettokensRequest
*/
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokens(ctx context.Context) DigitalWalletsManagementAPIGetDigitalwallettokensRequest {
	return DigitalWalletsManagementAPIGetDigitalwallettokensRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DigitalWalletTokenListResponse
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokensExecute(r DigitalWalletsManagementAPIGetDigitalwallettokensRequest) (*DigitalWalletTokenListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DigitalWalletTokenListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.GetDigitalwallettokens")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwallettokens"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-createdTime"
		r.sortBy = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "")
	}
	if r.panReferenceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pan_reference_id", r.panReferenceId, "")
	}
	if r.tokenReferenceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token_reference_id", r.tokenReferenceId, "")
	}
	if r.correlationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "correlation_id", r.correlationId, "")
	}
	if r.tokenType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token_type", r.tokenType, "")
	}
	if r.tokenRequestorName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token_requestor_name", r.tokenRequestorName, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DigitalWalletsManagementAPIGetDigitalwallettokensCardCardtokenRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	cardToken string
	count *int32
	startIndex *int32
	sortBy *string
}

// Number of digital wallet token resources to retrieve.
func (r DigitalWalletsManagementAPIGetDigitalwallettokensCardCardtokenRequest) Count(count int32) DigitalWalletsManagementAPIGetDigitalwallettokensCardCardtokenRequest {
	r.count = &count
	return r
}

// Sort order index of the first digital wallet token resource in the returned array.
func (r DigitalWalletsManagementAPIGetDigitalwallettokensCardCardtokenRequest) StartIndex(startIndex int32) DigitalWalletsManagementAPIGetDigitalwallettokensCardCardtokenRequest {
	r.startIndex = &startIndex
	return r
}

// Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
func (r DigitalWalletsManagementAPIGetDigitalwallettokensCardCardtokenRequest) SortBy(sortBy string) DigitalWalletsManagementAPIGetDigitalwallettokensCardCardtokenRequest {
	r.sortBy = &sortBy
	return r
}

func (r DigitalWalletsManagementAPIGetDigitalwallettokensCardCardtokenRequest) Execute() (*DigitalWalletTokenListResponse, *http.Response, error) {
	return r.ApiService.GetDigitalwallettokensCardCardtokenExecute(r)
}

/*
GetDigitalwallettokensCardCardtoken List digital wallet tokens for card

Use this endpoint to return an array of all digital wallet tokens for a particular card.

This endpoint supports <</core-api/sorting-and-pagination, pagination>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cardToken Unique identifier of the card. Used to minimize the need to exchange card details during subsequent calls, and also for troubleshooting.
 @return DigitalWalletsManagementAPIGetDigitalwallettokensCardCardtokenRequest
*/
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokensCardCardtoken(ctx context.Context, cardToken string) DigitalWalletsManagementAPIGetDigitalwallettokensCardCardtokenRequest {
	return DigitalWalletsManagementAPIGetDigitalwallettokensCardCardtokenRequest{
		ApiService: a,
		ctx: ctx,
		cardToken: cardToken,
	}
}

// Execute executes the request
//  @return DigitalWalletTokenListResponse
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokensCardCardtokenExecute(r DigitalWalletsManagementAPIGetDigitalwallettokensCardCardtokenRequest) (*DigitalWalletTokenListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DigitalWalletTokenListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.GetDigitalwallettokensCardCardtoken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwallettokens/card/{card_token}"
	localVarPath = strings.Replace(localVarPath, "{"+"card_token"+"}", url.PathEscape(parameterValueToString(r.cardToken, "cardToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-createdTime"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DigitalWalletsManagementAPIGetDigitalwallettokensTokenRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	token string
}

func (r DigitalWalletsManagementAPIGetDigitalwallettokensTokenRequest) Execute() (*DigitalWalletToken, *http.Response, error) {
	return r.ApiService.GetDigitalwallettokensTokenExecute(r)
}

/*
GetDigitalwallettokensToken Retrieve digital wallet token

Use this endpoint to retrieve a specific digital wallet token.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the digital wallet token (DWT).
 @return DigitalWalletsManagementAPIGetDigitalwallettokensTokenRequest
*/
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokensToken(ctx context.Context, token string) DigitalWalletsManagementAPIGetDigitalwallettokensTokenRequest {
	return DigitalWalletsManagementAPIGetDigitalwallettokensTokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return DigitalWalletToken
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokensTokenExecute(r DigitalWalletsManagementAPIGetDigitalwallettokensTokenRequest) (*DigitalWalletToken, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DigitalWalletToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.GetDigitalwallettokensToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwallettokens/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DigitalWalletsManagementAPIGetDigitalwallettokensTokenShowtokenpanRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	token string
}

func (r DigitalWalletsManagementAPIGetDigitalwallettokensTokenShowtokenpanRequest) Execute() (*DigitalWalletToken, *http.Response, error) {
	return r.ApiService.GetDigitalwallettokensTokenShowtokenpanExecute(r)
}

/*
GetDigitalwallettokensTokenShowtokenpan Retrieve digital wallet token PAN

Use this endpoint to retrieve a digital wallet token with the entire primary account number (PAN) displayed.
The PAN returned is of the digital wallet token and not of the card.
(For security reasons, the PAN is not fully visible on the digital wallet token returned by `GET` `/digitalwallettokens/{token}`.)

[WARNING]
Sending a request to this endpoint requires PCI DSS compliance.
You must comply with PCI DSS data security requirements if you want to store, transmit, or process sensitive card data such as the cardholder's primary account number (PAN), personal identification number (PIN), and card expiration date.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the digital wallet token (DWT).
 @return DigitalWalletsManagementAPIGetDigitalwallettokensTokenShowtokenpanRequest
*/
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokensTokenShowtokenpan(ctx context.Context, token string) DigitalWalletsManagementAPIGetDigitalwallettokensTokenShowtokenpanRequest {
	return DigitalWalletsManagementAPIGetDigitalwallettokensTokenShowtokenpanRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return DigitalWalletToken
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokensTokenShowtokenpanExecute(r DigitalWalletsManagementAPIGetDigitalwallettokensTokenShowtokenpanRequest) (*DigitalWalletToken, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DigitalWalletToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.GetDigitalwallettokensTokenShowtokenpan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwallettokens/{token}/showtokenpan"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DigitalWalletsManagementAPIGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	token string
	count *int32
	startIndex *int32
	fields *string
	sortBy *string
}

// Number of digital wallet transitions to retrieve.
func (r DigitalWalletsManagementAPIGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest) Count(count int32) DigitalWalletsManagementAPIGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest {
	r.count = &count
	return r
}

// The sort order index of the first digital wallet token in the returned array.
func (r DigitalWalletsManagementAPIGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest) StartIndex(startIndex int32) DigitalWalletsManagementAPIGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest {
	r.startIndex = &startIndex
	return r
}

// Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
func (r DigitalWalletsManagementAPIGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest) Fields(fields string) DigitalWalletsManagementAPIGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest {
	r.fields = &fields
	return r
}

// Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
func (r DigitalWalletsManagementAPIGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest) SortBy(sortBy string) DigitalWalletsManagementAPIGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest {
	r.sortBy = &sortBy
	return r
}

func (r DigitalWalletsManagementAPIGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest) Execute() (*DigitalWalletTokenTransitionListResponse, *http.Response, error) {
	return r.ApiService.GetDigitalwallettokentransitionsDigitalwallettokenTokenExecute(r)
}

/*
GetDigitalwallettokentransitionsDigitalwallettokenToken List transitions for digital wallet token

Use this endpoint to return an array of all transitions for a particular digital wallet token.

This endpoint supports <</core-api/field-filtering, field filtering>>, <</core-api/sorting-and-pagination, pagination>>, and <</core-api/sorting-and-pagination, sorting>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the digital wallet token (DWT).
 @return DigitalWalletsManagementAPIGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest
*/
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokentransitionsDigitalwallettokenToken(ctx context.Context, token string) DigitalWalletsManagementAPIGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest {
	return DigitalWalletsManagementAPIGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return DigitalWalletTokenTransitionListResponse
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokentransitionsDigitalwallettokenTokenExecute(r DigitalWalletsManagementAPIGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest) (*DigitalWalletTokenTransitionListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DigitalWalletTokenTransitionListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.GetDigitalwallettokentransitionsDigitalwallettokenToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwallettokentransitions/digitalwallettoken/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-id"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DigitalWalletsManagementAPIGetDigitalwallettokentransitionsTokenRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	token string
	fields *string
}

// Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
func (r DigitalWalletsManagementAPIGetDigitalwallettokentransitionsTokenRequest) Fields(fields string) DigitalWalletsManagementAPIGetDigitalwallettokentransitionsTokenRequest {
	r.fields = &fields
	return r
}

func (r DigitalWalletsManagementAPIGetDigitalwallettokentransitionsTokenRequest) Execute() (*DigitalWalletTokenTransitionResponse, *http.Response, error) {
	return r.ApiService.GetDigitalwallettokentransitionsTokenExecute(r)
}

/*
GetDigitalwallettokentransitionsToken Retrieve digital wallet token transition

Use this endpoint to retrieve a specific digital wallet token transition.

This endpoint supports <</core-api/field-filtering, field filtering>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the digital wallet token (DWT) transition.
 @return DigitalWalletsManagementAPIGetDigitalwallettokentransitionsTokenRequest
*/
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokentransitionsToken(ctx context.Context, token string) DigitalWalletsManagementAPIGetDigitalwallettokentransitionsTokenRequest {
	return DigitalWalletsManagementAPIGetDigitalwallettokentransitionsTokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return DigitalWalletTokenTransitionResponse
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokentransitionsTokenExecute(r DigitalWalletsManagementAPIGetDigitalwallettokentransitionsTokenRequest) (*DigitalWalletTokenTransitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DigitalWalletTokenTransitionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.GetDigitalwallettokentransitionsToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwallettokentransitions/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsAndroidpayRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	digitalWalletAndroidPayProvisionRequest *DigitalWalletAndroidPayProvisionRequest
}

func (r DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsAndroidpayRequest) DigitalWalletAndroidPayProvisionRequest(digitalWalletAndroidPayProvisionRequest DigitalWalletAndroidPayProvisionRequest) DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsAndroidpayRequest {
	r.digitalWalletAndroidPayProvisionRequest = &digitalWalletAndroidPayProvisionRequest
	return r
}

func (r DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsAndroidpayRequest) Execute() (*DigitalWalletAndroidPayProvisionResponse, *http.Response, error) {
	return r.ApiService.PostDigitalwalletprovisionrequestsAndroidpayExecute(r)
}

/*
PostDigitalwalletprovisionrequestsAndroidpay Create digital wallet token provisioning request for Google Wallet

Use this endpoint to return card data for use in provisioning a digital wallet token into Google Wallet.

The returned card data is encrypted using the digital wallet provider's encryption key, thereby reducing your PCI compliance overhead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsAndroidpayRequest
*/
func (a *DigitalWalletsManagementAPIService) PostDigitalwalletprovisionrequestsAndroidpay(ctx context.Context) DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsAndroidpayRequest {
	return DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsAndroidpayRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DigitalWalletAndroidPayProvisionResponse
func (a *DigitalWalletsManagementAPIService) PostDigitalwalletprovisionrequestsAndroidpayExecute(r DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsAndroidpayRequest) (*DigitalWalletAndroidPayProvisionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DigitalWalletAndroidPayProvisionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.PostDigitalwalletprovisionrequestsAndroidpay")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwalletprovisionrequests/androidpay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.digitalWalletAndroidPayProvisionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsApplepayRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	digitalWalletApplePayProvisionRequest *DigitalWalletApplePayProvisionRequest
}

func (r DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsApplepayRequest) DigitalWalletApplePayProvisionRequest(digitalWalletApplePayProvisionRequest DigitalWalletApplePayProvisionRequest) DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsApplepayRequest {
	r.digitalWalletApplePayProvisionRequest = &digitalWalletApplePayProvisionRequest
	return r
}

func (r DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsApplepayRequest) Execute() (*DigitalWalletApplePayProvisionResponse, *http.Response, error) {
	return r.ApiService.PostDigitalwalletprovisionrequestsApplepayExecute(r)
}

/*
PostDigitalwalletprovisionrequestsApplepay Create digital wallet token provisioning request for Apple Wallet

Use this endpoint to return card data for use in provisioning a digital wallet token into Apple Wallet.

The returned card data is encrypted using the digital wallet provider's encryption key, thereby reducing your PCI compliance overhead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsApplepayRequest
*/
func (a *DigitalWalletsManagementAPIService) PostDigitalwalletprovisionrequestsApplepay(ctx context.Context) DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsApplepayRequest {
	return DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsApplepayRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DigitalWalletApplePayProvisionResponse
func (a *DigitalWalletsManagementAPIService) PostDigitalwalletprovisionrequestsApplepayExecute(r DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsApplepayRequest) (*DigitalWalletApplePayProvisionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DigitalWalletApplePayProvisionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.PostDigitalwalletprovisionrequestsApplepay")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwalletprovisionrequests/applepay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.digitalWalletApplePayProvisionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsSamsungpayRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	digitalWalletSamsungPayProvisionRequest *DigitalWalletSamsungPayProvisionRequest
}

func (r DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsSamsungpayRequest) DigitalWalletSamsungPayProvisionRequest(digitalWalletSamsungPayProvisionRequest DigitalWalletSamsungPayProvisionRequest) DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsSamsungpayRequest {
	r.digitalWalletSamsungPayProvisionRequest = &digitalWalletSamsungPayProvisionRequest
	return r
}

func (r DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsSamsungpayRequest) Execute() (*DigitalWalletSamsungPayProvisionResponse, *http.Response, error) {
	return r.ApiService.PostDigitalwalletprovisionrequestsSamsungpayExecute(r)
}

/*
PostDigitalwalletprovisionrequestsSamsungpay Create digital wallet token provisioning request for Samsung Wallet

[NOTE]
This endpoint is limited in availability.
For more information, contact your Marqeta representative.

Use this endpoint to return card data for use in provisioning a digital wallet token into Samsung Wallet.

The returned card data is encrypted using the digital wallet provider's encryption key, thereby reducing your PCI compliance overhead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsSamsungpayRequest
*/
func (a *DigitalWalletsManagementAPIService) PostDigitalwalletprovisionrequestsSamsungpay(ctx context.Context) DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsSamsungpayRequest {
	return DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsSamsungpayRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DigitalWalletSamsungPayProvisionResponse
func (a *DigitalWalletsManagementAPIService) PostDigitalwalletprovisionrequestsSamsungpayExecute(r DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsSamsungpayRequest) (*DigitalWalletSamsungPayProvisionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DigitalWalletSamsungPayProvisionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.PostDigitalwalletprovisionrequestsSamsungpay")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwalletprovisionrequests/samsungpay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.digitalWalletSamsungPayProvisionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsXPayRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	digitalWalletXPayProvisionRequest *DigitalWalletXPayProvisionRequest
}

func (r DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsXPayRequest) DigitalWalletXPayProvisionRequest(digitalWalletXPayProvisionRequest DigitalWalletXPayProvisionRequest) DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsXPayRequest {
	r.digitalWalletXPayProvisionRequest = &digitalWalletXPayProvisionRequest
	return r
}

func (r DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsXPayRequest) Execute() (*DigitalWalletXPayProvisionResponse, *http.Response, error) {
	return r.ApiService.PostDigitalwalletprovisionrequestsXPayExecute(r)
}

/*
PostDigitalwalletprovisionrequestsXPay Create digital wallet token provisioning request for XPay

[NOTE]
This endpoint is limited in availability.
For more information, contact your Marqeta representative.

Use this endpoint to return card data for use in provisioning a digital wallet token into an XPay digital wallet.

The returned card data is encrypted using the digital wallet provider's encryption key, thereby reducing your PCI compliance overhead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsXPayRequest
*/
func (a *DigitalWalletsManagementAPIService) PostDigitalwalletprovisionrequestsXPay(ctx context.Context) DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsXPayRequest {
	return DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsXPayRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DigitalWalletXPayProvisionResponse
func (a *DigitalWalletsManagementAPIService) PostDigitalwalletprovisionrequestsXPayExecute(r DigitalWalletsManagementAPIPostDigitalwalletprovisionrequestsXPayRequest) (*DigitalWalletXPayProvisionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DigitalWalletXPayProvisionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.PostDigitalwalletprovisionrequestsXPay")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwalletprovisionrequests/xpay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.digitalWalletXPayProvisionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DigitalWalletsManagementAPIPostDigitalwallettokentransitionsRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	digitalWalletTokenTransitionRequest *DigitalWalletTokenTransitionRequest
}

func (r DigitalWalletsManagementAPIPostDigitalwallettokentransitionsRequest) DigitalWalletTokenTransitionRequest(digitalWalletTokenTransitionRequest DigitalWalletTokenTransitionRequest) DigitalWalletsManagementAPIPostDigitalwallettokentransitionsRequest {
	r.digitalWalletTokenTransitionRequest = &digitalWalletTokenTransitionRequest
	return r
}

func (r DigitalWalletsManagementAPIPostDigitalwallettokentransitionsRequest) Execute() (*DigitalWalletTokenTransitionResponse, *http.Response, error) {
	return r.ApiService.PostDigitalwallettokentransitionsExecute(r)
}

/*
PostDigitalwallettokentransitions Create digital wallet token transition

Use this endpoint to transition a digital wallet token from one state to another.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DigitalWalletsManagementAPIPostDigitalwallettokentransitionsRequest
*/
func (a *DigitalWalletsManagementAPIService) PostDigitalwallettokentransitions(ctx context.Context) DigitalWalletsManagementAPIPostDigitalwallettokentransitionsRequest {
	return DigitalWalletsManagementAPIPostDigitalwallettokentransitionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DigitalWalletTokenTransitionResponse
func (a *DigitalWalletsManagementAPIService) PostDigitalwallettokentransitionsExecute(r DigitalWalletsManagementAPIPostDigitalwallettokentransitionsRequest) (*DigitalWalletTokenTransitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DigitalWalletTokenTransitionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.PostDigitalwallettokentransitions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwallettokentransitions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.digitalWalletTokenTransitionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DigitalWalletsManagementAPISendOPCDataToGooglePayRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	reqSysId *string
	sendingProvisioningDataToGooglePayBackendRequest *SendingProvisioningDataToGooglePayBackendRequest
}

// Random pseudo-unique value used for troubleshooting between multiple parties.
func (r DigitalWalletsManagementAPISendOPCDataToGooglePayRequest) ReqSysId(reqSysId string) DigitalWalletsManagementAPISendOPCDataToGooglePayRequest {
	r.reqSysId = &reqSysId
	return r
}

func (r DigitalWalletsManagementAPISendOPCDataToGooglePayRequest) SendingProvisioningDataToGooglePayBackendRequest(sendingProvisioningDataToGooglePayBackendRequest SendingProvisioningDataToGooglePayBackendRequest) DigitalWalletsManagementAPISendOPCDataToGooglePayRequest {
	r.sendingProvisioningDataToGooglePayBackendRequest = &sendingProvisioningDataToGooglePayBackendRequest
	return r
}

func (r DigitalWalletsManagementAPISendOPCDataToGooglePayRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendOPCDataToGooglePayExecute(r)
}

/*
SendOPCDataToGooglePay Create request for Google Wallet web push provisioning

[NOTE]
This endpoint is currently in beta and subject to change.
For more information, contact your Marqeta representative.

Use this endpoint to add a card to Google Wallet via a web application.

This endpoint does not return a payload in response to a request.
Instead, a successful call will return a response code only.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DigitalWalletsManagementAPISendOPCDataToGooglePayRequest
*/
func (a *DigitalWalletsManagementAPIService) SendOPCDataToGooglePay(ctx context.Context) DigitalWalletsManagementAPISendOPCDataToGooglePayRequest {
	return DigitalWalletsManagementAPISendOPCDataToGooglePayRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DigitalWalletsManagementAPIService) SendOPCDataToGooglePayExecute(r DigitalWalletsManagementAPISendOPCDataToGooglePayRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.SendOPCDataToGooglePay")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwallets/wpp/googlePayPushProvisioningNotification"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reqSysId == nil {
		return nil, reportError("reqSysId is required and must be specified")
	}
	if r.sendingProvisioningDataToGooglePayBackendRequest == nil {
		return nil, reportError("sendingProvisioningDataToGooglePayBackendRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "req-sys-id", r.reqSysId, "")
	// body params
	localVarPostBody = r.sendingProvisioningDataToGooglePayBackendRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessageFromWebPushProvisioningRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessageFromWebPushProvisioningRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageFromWebPushProvisioningRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
